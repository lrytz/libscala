#!/usr/bin/env bash
#
# Based on info from
#   http://stackoverflow.com/questions/359424/detach-subdirectory-into-separate-git-repository

set -e

if [[ $# -ne 2 ]]; then
  echo "Usage: $0 <repo> <subdir>";
  exit 1;
fi

repo="$1"
subdir="$2"
staging="${repo}-temp-filter"

cd "$repo"
repopath=$(pwd)
cd ..

if [[ -e "$subdir" ]]; then
  echo "$subdir already exists at top level, bailing."
  exit 1
fi

# Make a fresh copy of the repo of interest in -temp-filter
git clone --no-hardlinks "$repo" "$staging"
cd "$staging"

# Run filter-branch as desired
echo "Filtering $staging..."
git filter-branch --subdirectory-filter "$subdir" --prune-empty --tag-name-filter cat -- --all

# Sidestep the many challenges of making git "really" forget about
# removed files by cloning the filtered repo.
cd "$repopath/.."
git clone "$staging" "$subdir"
cd "$subdir"

# Now expiring everything works without too long a song and dance.
echo ""
echo "Scrubbing $subdir repository..."
git remote rm origin
git reflog expire --expire=now --all
git repack -ad
git gc --prune=now --aggressive

# Remove the intermediate repo.
cd "$repopath/.."
if [[ -d "$staging" ]]; then
  echo "Removing temporary repository $staging..."
  rm -rf "$staging"
fi

# 
# git remote rm origin
# git update-ref -d refs/original/refs/heads/master
# git reflog expire --expire=now --all
# git repack -ad
# git reset --hard
# git gc --aggressive
# git prune
# git filter-branch --index-filter "git rm -r -f --cached --ignore-unmatch $subdir" --prune-empty HEAD -- --all
# # git filter-branch --subdirectory-filter $subdir HEAD -- --all
# git reset --hard
# git gc --aggressive
# git prune
